package edu.neu.madcourse.binbo;

public class BogglePuzzle {
	protected char[] mPuzzle = null;
	protected int mSize = 4;
	
	public BogglePuzzle(int size) {
		makePuzzle(size);
	}
	
	public void makePuzzle(int size) {	
		mSize = size;
		
		StringBuffer sf = new StringBuffer();		
		int count = mSize * mSize;		
		char letters[] = new char[count];			
		
		for (int i = 0; i < count; ++i) {
			letters[i] = ' ';
		}
		for (int i = 0; i < count; ++i) {
			char letter = makeLetter();
			letters[i] = letter;
			while (isTooMuchRepeated(letters, letter)) {
				letter = makeLetter(); // try to make another letter
				letters[i] = letter;
			}
			sf.append(String.valueOf(letter));
		}

		mPuzzle = sf.toString().toCharArray();
	}
	
	public void rotatePuzzle() {
		char[] new_puzzle = new char[mSize * mSize];  	
		
		int k = 0;
		for (int i = 0; i < mSize; ++i) {
			for (int j = mSize - 1; j >= 0; --j) {
				new_puzzle[mSize * j + i] = mPuzzle[k++];
			}
		}
		
		puzzle = new_puzzle;
		puzzleView.changePuzzleDirection();
		puzzleView.invalidate();
	}
	
	private boolean isRepeatedTooMuch(char[] letters, char letter) {
		int count = 0;
		
		for (int i = 0; i < letters.length; ++i) {
			if (letters[i] == letter) {
				++count;
			}
		}
		if (count > 3) {
			return true;
		} else if (count == 3) {
			int occurs[] = new int[26];
			for (int i = 0; i < 26; ++i) {
				occurs[i] = 0;
			}
			// get the occurrence of each letter
			for (int i = 0; i < letters.length; ++i) {
				int k = (int)letters[i] - 65;
				if (k >= 0) {
					occurs[k]++;
				}				 
			}		
			// check whether some other letter already occurred 3 times,
			// if so, the repeated letters are too much.
			for (int i = 0; i < 26; ++i) {
				if (occurs[i] > 2) {
					if ((char)(i + 65) == letter) // skip the current letter 
						continue;
					return true; // more than one letter occurred 3 times
				}
			}			
		}
		
		return false;
	}
	
	/** Generate every letter */
	private char generateLetter() {
		char letter = 'e';
		int l = 0, r = 0;
		int t = (int)(Math.random() * SUM_OF_CHARS);	
		
		int i;
		for (i = 0; i < 26; ++i) {
			r += FREQUENCY[i];
			if (l < t && t < r) {
				letter = (char)(65 + i);
				break;
			}
			l += FREQUENCY[i];
		}		
		assert(i < 26);
		
		return letter;
	}
}
